{"title":"Aritmética de Punto flotante","markdown":{"yaml":{"title":"Aritmética de Punto flotante"},"headingText":"Introducción.","containsRefs":false,"markdown":"\n\n\n\n\n**Objetivo general.**\n- Revisar y entender cómo funcionan los números y la aritmética de punto flotante.\n\n <p xmlns:cc=\"http://creativecommons.org/ns#\" xmlns:dct=\"http://purl.org/dc/terms/\"><a property=\"dct:title\" rel=\"cc:attributionURL\" href=\"https://github.com/repomacti/macti/tree/main/notebooks/Analisis_Numerico_01\">MACTI-Analisis_Numerico_01</a> by <a rel=\"cc:attributionURL dct:creator\" property=\"cc:attributionName\" href=\"https://www.macti.unam.mx\">Luis M. de la Cruz</a> is licensed under <a href=\"http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1\" target=\"_blank\" rel=\"license noopener noreferrer\" style=\"display:inline-block;\">Attribution-ShareAlike 4.0 International<img style=\"height:22px!important;margin-left:3px;vertical-align:text-bottom;\" src=\"https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1\"><img style=\"height:22px!important;margin-left:3px;vertical-align:text-bottom;\" src=\"https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1\"><img style=\"height:22px!important;margin-left:3px;vertical-align:text-bottom;\" src=\"https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1\"></a></p> \n\nTrabajo realizado con el apoyo del Programa UNAM-DGAPA-PAPIME PE101922\n\n\n\nLa aritmética que se realiza en una computadora digital es diferente de la que se usa en matemáticas, por ejemplo: \n* $2 + 2 = 4$\n\n* $4^2 = 16$\n\n* $ \\left(\\sqrt{3}\\right)^2 = 3 $\n\nObserva que en este último ejemplo, el resultado no es exacto, solo aproximado al valor real.\n\nEn la aritmética continua se permite que un número real pueda tener un número infinito de dígitos.\n\n$$\\frac{1}{3} = 0.3333333 \\dots 33333 \\dots $$\n\nPero en una computadora solo puede representar un subconjunto de los números reales, el cual solo contiene números racionales (positivos y negativos).\n\nEn el hardware de una computadora, los números se aproximan en base binaria; particularmente los números de punto flotante se aproximan con fracciones binarias. Por ejemplo, la fracción binaria $0.101$ se aproxima como sigue:\n\n$$\n0.101 = \\frac{1}{2^1} + \\frac{0}{2^2} + \\frac{1}{2^3} = 0.5 + 0.125 = 0.625\n$$\n\nObserve que la suma de fracciones anterior se puede escribir como: \n\n$$\n\\frac{1 * 2^2 + 1}{2^3} = \\frac{5}{2^3} = 0.625 \n$$\n\nes decir, la representación del número $0.625$ está dada en la forma: $\\displaystyle \\frac{J}{2^N}$.\n\nEn base 10 el número anterior se puede representar somo sigue:\n\n$$\n0.625 = \\frac{6}{10} + \\frac{2}{10^2} + \\frac{5}{10^3}\n$$\n\n**Pero no siempre es posible representar los números de punto flotante con fracciones binarias**.\n\nComo se puedo observar anteriormente, la fracción $1/3$ se puede aproximar como una fracción en base $10$. Por ejemplo: \n$$\n\\begin{eqnarray}\n0.3 & = & \\frac{3}{10} \\\\\n0.33 & = & \\frac{3}{10} + \\frac{3}{100} \\\\\n0.333 & = &\\frac{3}{10} + \\frac{3}{100} + \\frac{3}{1000}\n\\end{eqnarray}\n$$\n\nPero en binario no es posible representar $1/3$ de manera exacta. \n\nOtro ejemplo es el número $0.1 = 1/10$:\n\nExisten varios números decimales que comparten la misma fracción binaria más aproximada. \n\nPor ejemplo, los siguientes números \n$$\n\\begin{array}{l}\n0.1 \\\\ \n0.10000000000000001 \\\\ \n0.1000000000000000055511151231257827021181583404541015625\n\\end{array}\n$$\n\nson todos aproximados por la siguiente fracción:\n$$\n\\frac{3602879701896397}{2^{55}} \n$$\n\nEsto es muy importante cuando se usan constantes matemáticas en cálculos numéricos\n\n**Observación**: Esto puede crear ciertas ilusiones sobre el valor real de un número.\n\n<div class=\"alert alert-info\">\n\n## **Ejemplo 1.**\n\n<font color=\"Black\">\n\n\n\n¿Que resultará de las siguientes evaluaciones?:\n```python\n0.1 == 1/10\n0.1 == repr(1/10)\nrepr(0.1) == 1/10\n.1 + .1 + .1 == 0.3\nround(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)\nround(.1 + .1 + .1, 10) == round(.3, 10)\n```\nExplique el resultado de las evaluaciones.\n\n**Hint**: Checar el valor más aproximado almacenado en memoria usando por ejemplo `format(x,'.52f')` y también usar el comando `type` para conocer el tipo de dato.\n\n</font>\n\n</div>\n\n# Sistema  Numérico de Punto Flotante\n\n- Las computadoras cuentan con una cierta capacidad finita para almacenar información. \n\n- Los números reales se representan mediante los llamados **números de punto flotante** (*floating point numbers*) usando las siguentes características:\n\n    1. Signo **+** o **-** .\n    2. Mantisa con $t$ dígitos; donde $t$ es un entero positivo mayor o igual a 1.\n    3. Base $\\beta$; donde $\\beta$ es un entero positivo mayor que 1\n    4. Exponente $e$; donde $m \\le e \\le M$ con $m \\le 0$ y $M > t$ <br><br>\n\n- Cada número de punto flotante se representa como:\n    $$\n    \\pm .d_1d_2d_3\\dots d_t \\times \\beta^e\n    $$\n    donde $0 \\le d_i \\le \\beta - 1 \\,\\,\\, (i= 1,2,3,\\dots , t)$\n- La forma normalizada ocurre cuando $d_1 \\neq 0$\n\n- El número de dígitos en la mantisa es finito, lo que propicia un error en la representación y en las operaciones aritméticas\n\n<div class=\"alert alert-info\">\n\n## **Ejemplo 2.**\n\n<font color=\"Black\"> IBM 3000 series \n\n- Sistema numérico de punto flotante (SNPF) de simple precisión: 1 dígito binario (bit) para el signo, 7 bits para el exponente en base 16, y 24 bits para la mantisa.\n    - 24 dígitos binarios corresponde a $\\approx$ 6 dígitos decimales.\n    - El exponente va de 0000000 = 0 a 1111111 = 127. \n    - Para asegurar la representación de números de magnitud pequeña, se resta 64 al exponente, de tal manera que el rango en realidad es de -64 a 63.\n\n</font>\n</div>\n\n\n|Signo|$$e$$|$$t$$|\n|---|---|---|\n|0|1000010|101100110000010000000000|\n| | | |\n\n$$\n1000010 = 1 \\cdot 2^6 + 0 \\cdot 2^5 + 0 \\cdot 0^4 + 0 \\cdot 2^3 + \n0 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0  = 66\n\\Longrightarrow 16^{66-64}.\n$$\n\n$$\n\\left[\n\\left(\\frac{1}{2}\\right)^1 + \\left(\\frac{1}{2}\\right)^3 +\n\\left(\\frac{1}{2}\\right)^4 + \\left(\\frac{1}{2}\\right)^7 +\n\\left(\\frac{1}{2}\\right)^8 + \\left(\\frac{1}{2}\\right)^{14} \n\\right] 16^{66-64} = 179.015625\n$$\n\n- En este sistema, el siguiente número más pequeño y el siguiente más grande son:\n\n\n|0 |1000010 |101100110000001111111111 | = | 179.0156097412109375 |\n|---|---|---|---|---|\n|0 |1000010 |101100110000010000000001 | = | 179.0156402587890625 |\n\n$$\n\\Longrightarrow  179.015625 \\mbox{ representa } [179.0156097412109375, 179.0156402587890625]\n$$\n\n<br>\n\n<img src=\"floatingNumbers.png\" alt=\"Smiley\">\n\n\nEn 1985, el IEEE (Institute for Electrical and Electronic Engineers) publicó: *Binary Floating Point Arithmetic Standard 754, 1985 *.Se especifican los formatos para precisión simple, doble y extendida, y esos estándares son usados por muchos constructores de CPUs.\n\n# Error de representación\nRecordemos que muchas fracciones decimales no pueden representarse exactamente como fracciones binarias. Por esta razón, todos los lenguajes de programación no muestran el número decimal exacto que se espera.\n\nLa mayoría de las computadoras utilizan el estándar IEEE-754 para representar números de punto flotante. Los números de doble precisión en el IEEE-754 tienen 53 bits de precisión, por lo tanto, la representación del número $0.1$ en este sistema requiere de un número $J$, de 53 bits, tal que:\n\n$$\n\\frac{J}{2^N} \\approx 0.1\n$$\n\nUsando la fórmula anterior tenemos que:\n\n$$\nJ \\approx \\frac{2^N}{10}\n$$\n\nDado que $J$ debe tener exactamente 53 bits, entonces se cumple que $2^{52} \\leq J \\leq 2^{53}$. Se puede comprobar fácilmente que para que esto ocurra, entonces $N = 56$:\n\nObserve que en la celda anterior realizamos la división entera con el propósito de comparar con otros valores enteros. Si hacemos el cálculo usando flotantes y luego convertimos a entero obtenemos el valor requerido de $J$:\n\nEntonces, la representación de $0.1$ en este sistema es $\\displaystyle \\frac{7205759403792794}{2^{56}}$ que se puede reducir a \n$\\displaystyle \\frac{3602879701896397}{2^{55}}$, por lo tanto:\n\nLa mayoría de los lenguajes utilizan 17 dígitos significativos para desplegar los números de punto flotante:\n\n# Algunas funciones útiles\n\n**Conversión decimal a hexadecimal**\n\nEl uso de hexadecimales es útil para portabilidad de valores entre diferentes versiones de Python y para el intercambio de información con otros lenguajes.\n\n**Mitigación del error**\n\nEs posible que en algunos casos se pierda precisión de tal manera que el resultado se vea afectado, por ejemplo:\n\nLa función `math.fsum()`ayuda **a mitigar** la pérdida de precisión durante la suma.\n\n**Decimal**\n\nCon esta biblioteca, los números se pueden representar de manera exacta y es my útil cuando se requiere de una \"aritmética exacta\".\n\n**Truncamiento y redondeo**\n\nDado el número $\\pi = 3.1415926535897931159979634 \\dots  = 0.31415926535897931159979634 \\dots \\times 10^1$, podemos hacer lo siguiente:\n\n- **Truncamiento**: Usando 5 dígitos: $0.31415 \\times 10^1 = 3.1415 $\n- **Redondeo**: Usando 5 dígitos: $(0.31415 + 0.00001) \\times 10^1 = 3.1416$\n\n\nOpciones de redondeo: \n- ROUND_CEILING, \n- ROUND_DOWN, \n- ROUND_FLOOR, \n- ROUND_HALF_DOWN, \n- ROUND_HALF_EVEN, \n- ROUND_HALF_UP, \n- ROUND_UP, \n- ROUND_05UP.\n\n**Fractions**\n\n# Características del SNPF en Python 3\n\n<font color=##009900>**NumPy**</font> soporta una variedad más amplia de tipos numéricos.\n\n<img src=\"dataTypes.png\" alt=\"Smiley\">\n\n\n- Para entender esto con mayor detalle véase:\n    - http://www.lahey.com/float.htm\n    - https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html\n","srcMarkdownNoYaml":"\n\n\n\n\n**Objetivo general.**\n- Revisar y entender cómo funcionan los números y la aritmética de punto flotante.\n\n <p xmlns:cc=\"http://creativecommons.org/ns#\" xmlns:dct=\"http://purl.org/dc/terms/\"><a property=\"dct:title\" rel=\"cc:attributionURL\" href=\"https://github.com/repomacti/macti/tree/main/notebooks/Analisis_Numerico_01\">MACTI-Analisis_Numerico_01</a> by <a rel=\"cc:attributionURL dct:creator\" property=\"cc:attributionName\" href=\"https://www.macti.unam.mx\">Luis M. de la Cruz</a> is licensed under <a href=\"http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1\" target=\"_blank\" rel=\"license noopener noreferrer\" style=\"display:inline-block;\">Attribution-ShareAlike 4.0 International<img style=\"height:22px!important;margin-left:3px;vertical-align:text-bottom;\" src=\"https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1\"><img style=\"height:22px!important;margin-left:3px;vertical-align:text-bottom;\" src=\"https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1\"><img style=\"height:22px!important;margin-left:3px;vertical-align:text-bottom;\" src=\"https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1\"></a></p> \n\nTrabajo realizado con el apoyo del Programa UNAM-DGAPA-PAPIME PE101922\n\n\n\n# Introducción.\nLa aritmética que se realiza en una computadora digital es diferente de la que se usa en matemáticas, por ejemplo: \n* $2 + 2 = 4$\n\n* $4^2 = 16$\n\n* $ \\left(\\sqrt{3}\\right)^2 = 3 $\n\nObserva que en este último ejemplo, el resultado no es exacto, solo aproximado al valor real.\n\nEn la aritmética continua se permite que un número real pueda tener un número infinito de dígitos.\n\n$$\\frac{1}{3} = 0.3333333 \\dots 33333 \\dots $$\n\nPero en una computadora solo puede representar un subconjunto de los números reales, el cual solo contiene números racionales (positivos y negativos).\n\nEn el hardware de una computadora, los números se aproximan en base binaria; particularmente los números de punto flotante se aproximan con fracciones binarias. Por ejemplo, la fracción binaria $0.101$ se aproxima como sigue:\n\n$$\n0.101 = \\frac{1}{2^1} + \\frac{0}{2^2} + \\frac{1}{2^3} = 0.5 + 0.125 = 0.625\n$$\n\nObserve que la suma de fracciones anterior se puede escribir como: \n\n$$\n\\frac{1 * 2^2 + 1}{2^3} = \\frac{5}{2^3} = 0.625 \n$$\n\nes decir, la representación del número $0.625$ está dada en la forma: $\\displaystyle \\frac{J}{2^N}$.\n\nEn base 10 el número anterior se puede representar somo sigue:\n\n$$\n0.625 = \\frac{6}{10} + \\frac{2}{10^2} + \\frac{5}{10^3}\n$$\n\n**Pero no siempre es posible representar los números de punto flotante con fracciones binarias**.\n\nComo se puedo observar anteriormente, la fracción $1/3$ se puede aproximar como una fracción en base $10$. Por ejemplo: \n$$\n\\begin{eqnarray}\n0.3 & = & \\frac{3}{10} \\\\\n0.33 & = & \\frac{3}{10} + \\frac{3}{100} \\\\\n0.333 & = &\\frac{3}{10} + \\frac{3}{100} + \\frac{3}{1000}\n\\end{eqnarray}\n$$\n\nPero en binario no es posible representar $1/3$ de manera exacta. \n\nOtro ejemplo es el número $0.1 = 1/10$:\n\nExisten varios números decimales que comparten la misma fracción binaria más aproximada. \n\nPor ejemplo, los siguientes números \n$$\n\\begin{array}{l}\n0.1 \\\\ \n0.10000000000000001 \\\\ \n0.1000000000000000055511151231257827021181583404541015625\n\\end{array}\n$$\n\nson todos aproximados por la siguiente fracción:\n$$\n\\frac{3602879701896397}{2^{55}} \n$$\n\nEsto es muy importante cuando se usan constantes matemáticas en cálculos numéricos\n\n**Observación**: Esto puede crear ciertas ilusiones sobre el valor real de un número.\n\n<div class=\"alert alert-info\">\n\n## **Ejemplo 1.**\n\n<font color=\"Black\">\n\n\n\n¿Que resultará de las siguientes evaluaciones?:\n```python\n0.1 == 1/10\n0.1 == repr(1/10)\nrepr(0.1) == 1/10\n.1 + .1 + .1 == 0.3\nround(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)\nround(.1 + .1 + .1, 10) == round(.3, 10)\n```\nExplique el resultado de las evaluaciones.\n\n**Hint**: Checar el valor más aproximado almacenado en memoria usando por ejemplo `format(x,'.52f')` y también usar el comando `type` para conocer el tipo de dato.\n\n</font>\n\n</div>\n\n# Sistema  Numérico de Punto Flotante\n\n- Las computadoras cuentan con una cierta capacidad finita para almacenar información. \n\n- Los números reales se representan mediante los llamados **números de punto flotante** (*floating point numbers*) usando las siguentes características:\n\n    1. Signo **+** o **-** .\n    2. Mantisa con $t$ dígitos; donde $t$ es un entero positivo mayor o igual a 1.\n    3. Base $\\beta$; donde $\\beta$ es un entero positivo mayor que 1\n    4. Exponente $e$; donde $m \\le e \\le M$ con $m \\le 0$ y $M > t$ <br><br>\n\n- Cada número de punto flotante se representa como:\n    $$\n    \\pm .d_1d_2d_3\\dots d_t \\times \\beta^e\n    $$\n    donde $0 \\le d_i \\le \\beta - 1 \\,\\,\\, (i= 1,2,3,\\dots , t)$\n- La forma normalizada ocurre cuando $d_1 \\neq 0$\n\n- El número de dígitos en la mantisa es finito, lo que propicia un error en la representación y en las operaciones aritméticas\n\n<div class=\"alert alert-info\">\n\n## **Ejemplo 2.**\n\n<font color=\"Black\"> IBM 3000 series \n\n- Sistema numérico de punto flotante (SNPF) de simple precisión: 1 dígito binario (bit) para el signo, 7 bits para el exponente en base 16, y 24 bits para la mantisa.\n    - 24 dígitos binarios corresponde a $\\approx$ 6 dígitos decimales.\n    - El exponente va de 0000000 = 0 a 1111111 = 127. \n    - Para asegurar la representación de números de magnitud pequeña, se resta 64 al exponente, de tal manera que el rango en realidad es de -64 a 63.\n\n</font>\n</div>\n\n\n|Signo|$$e$$|$$t$$|\n|---|---|---|\n|0|1000010|101100110000010000000000|\n| | | |\n\n$$\n1000010 = 1 \\cdot 2^6 + 0 \\cdot 2^5 + 0 \\cdot 0^4 + 0 \\cdot 2^3 + \n0 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0  = 66\n\\Longrightarrow 16^{66-64}.\n$$\n\n$$\n\\left[\n\\left(\\frac{1}{2}\\right)^1 + \\left(\\frac{1}{2}\\right)^3 +\n\\left(\\frac{1}{2}\\right)^4 + \\left(\\frac{1}{2}\\right)^7 +\n\\left(\\frac{1}{2}\\right)^8 + \\left(\\frac{1}{2}\\right)^{14} \n\\right] 16^{66-64} = 179.015625\n$$\n\n- En este sistema, el siguiente número más pequeño y el siguiente más grande son:\n\n\n|0 |1000010 |101100110000001111111111 | = | 179.0156097412109375 |\n|---|---|---|---|---|\n|0 |1000010 |101100110000010000000001 | = | 179.0156402587890625 |\n\n$$\n\\Longrightarrow  179.015625 \\mbox{ representa } [179.0156097412109375, 179.0156402587890625]\n$$\n\n<br>\n\n<img src=\"floatingNumbers.png\" alt=\"Smiley\">\n\n\nEn 1985, el IEEE (Institute for Electrical and Electronic Engineers) publicó: *Binary Floating Point Arithmetic Standard 754, 1985 *.Se especifican los formatos para precisión simple, doble y extendida, y esos estándares son usados por muchos constructores de CPUs.\n\n# Error de representación\nRecordemos que muchas fracciones decimales no pueden representarse exactamente como fracciones binarias. Por esta razón, todos los lenguajes de programación no muestran el número decimal exacto que se espera.\n\nLa mayoría de las computadoras utilizan el estándar IEEE-754 para representar números de punto flotante. Los números de doble precisión en el IEEE-754 tienen 53 bits de precisión, por lo tanto, la representación del número $0.1$ en este sistema requiere de un número $J$, de 53 bits, tal que:\n\n$$\n\\frac{J}{2^N} \\approx 0.1\n$$\n\nUsando la fórmula anterior tenemos que:\n\n$$\nJ \\approx \\frac{2^N}{10}\n$$\n\nDado que $J$ debe tener exactamente 53 bits, entonces se cumple que $2^{52} \\leq J \\leq 2^{53}$. Se puede comprobar fácilmente que para que esto ocurra, entonces $N = 56$:\n\nObserve que en la celda anterior realizamos la división entera con el propósito de comparar con otros valores enteros. Si hacemos el cálculo usando flotantes y luego convertimos a entero obtenemos el valor requerido de $J$:\n\nEntonces, la representación de $0.1$ en este sistema es $\\displaystyle \\frac{7205759403792794}{2^{56}}$ que se puede reducir a \n$\\displaystyle \\frac{3602879701896397}{2^{55}}$, por lo tanto:\n\nLa mayoría de los lenguajes utilizan 17 dígitos significativos para desplegar los números de punto flotante:\n\n# Algunas funciones útiles\n\n**Conversión decimal a hexadecimal**\n\nEl uso de hexadecimales es útil para portabilidad de valores entre diferentes versiones de Python y para el intercambio de información con otros lenguajes.\n\n**Mitigación del error**\n\nEs posible que en algunos casos se pierda precisión de tal manera que el resultado se vea afectado, por ejemplo:\n\nLa función `math.fsum()`ayuda **a mitigar** la pérdida de precisión durante la suma.\n\n**Decimal**\n\nCon esta biblioteca, los números se pueden representar de manera exacta y es my útil cuando se requiere de una \"aritmética exacta\".\n\n**Truncamiento y redondeo**\n\nDado el número $\\pi = 3.1415926535897931159979634 \\dots  = 0.31415926535897931159979634 \\dots \\times 10^1$, podemos hacer lo siguiente:\n\n- **Truncamiento**: Usando 5 dígitos: $0.31415 \\times 10^1 = 3.1415 $\n- **Redondeo**: Usando 5 dígitos: $(0.31415 + 0.00001) \\times 10^1 = 3.1416$\n\n\nOpciones de redondeo: \n- ROUND_CEILING, \n- ROUND_DOWN, \n- ROUND_FLOOR, \n- ROUND_HALF_DOWN, \n- ROUND_HALF_EVEN, \n- ROUND_HALF_UP, \n- ROUND_UP, \n- ROUND_05UP.\n\n**Fractions**\n\n# Características del SNPF en Python 3\n\n<font color=##009900>**NumPy**</font> soporta una variedad más amplia de tipos numéricos.\n\n<img src=\"dataTypes.png\" alt=\"Smiley\">\n\n\n- Para entender esto con mayor detalle véase:\n    - http://www.lahey.com/float.htm\n    - https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"01_AritmeticaDePuntoFlotante.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.550","theme":"cosmo","title":"Aritmética de Punto flotante"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"01_AritmeticaDePuntoFlotante.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"block-headings":true,"documentclass":"scrreprt","title":"Aritmética de Punto flotante"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}